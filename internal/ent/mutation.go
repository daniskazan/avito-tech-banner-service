// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/daniskazan/avito-tech-banner-service/internal/ent/banner"
	"github.com/daniskazan/avito-tech-banner-service/internal/ent/feature"
	"github.com/daniskazan/avito-tech-banner-service/internal/ent/predicate"
	"github.com/daniskazan/avito-tech-banner-service/internal/ent/tag"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBanner  = "Banner"
	TypeFeature = "Feature"
	TypeTag     = "Tag"
)

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	content        *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	is_active      *bool
	clearedFields  map[string]struct{}
	tags           map[int]struct{}
	removedtags    map[int]struct{}
	clearedtags    bool
	feature        map[int]struct{}
	removedfeature map[int]struct{}
	clearedfeature bool
	done           bool
	oldValue       func(context.Context) (*Banner, error)
	predicates     []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *BannerMutation) SetContent(value map[string]interface{}) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *BannerMutation) Content() (r map[string]interface{}, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldContent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BannerMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *BannerMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *BannerMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *BannerMutation) ResetIsActive() {
	m.is_active = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *BannerMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *BannerMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *BannerMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *BannerMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *BannerMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *BannerMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *BannerMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddFeatureIDs adds the "feature" edge to the Feature entity by ids.
func (m *BannerMutation) AddFeatureIDs(ids ...int) {
	if m.feature == nil {
		m.feature = make(map[int]struct{})
	}
	for i := range ids {
		m.feature[ids[i]] = struct{}{}
	}
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *BannerMutation) ClearFeature() {
	m.clearedfeature = true
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *BannerMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// RemoveFeatureIDs removes the "feature" edge to the Feature entity by IDs.
func (m *BannerMutation) RemoveFeatureIDs(ids ...int) {
	if m.removedfeature == nil {
		m.removedfeature = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feature, ids[i])
		m.removedfeature[ids[i]] = struct{}{}
	}
}

// RemovedFeature returns the removed IDs of the "feature" edge to the Feature entity.
func (m *BannerMutation) RemovedFeatureIDs() (ids []int) {
	for id := range m.removedfeature {
		ids = append(ids, id)
	}
	return
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
func (m *BannerMutation) FeatureIDs() (ids []int) {
	for id := range m.feature {
		ids = append(ids, id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *BannerMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
	m.removedfeature = nil
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.content != nil {
		fields = append(fields, banner.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.is_active != nil {
		fields = append(fields, banner.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldContent:
		return m.Content()
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	case banner.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldContent:
		return m.OldContent(ctx)
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banner.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldContent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banner.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldContent:
		m.ResetContent()
		return nil
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banner.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tags != nil {
		edges = append(edges, banner.EdgeTags)
	}
	if m.feature != nil {
		edges = append(edges, banner.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeFeature:
		ids := make([]ent.Value, 0, len(m.feature))
		for id := range m.feature {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, banner.EdgeTags)
	}
	if m.removedfeature != nil {
		edges = append(edges, banner.EdgeFeature)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeFeature:
		ids := make([]ent.Value, 0, len(m.removedfeature))
		for id := range m.removedfeature {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtags {
		edges = append(edges, banner.EdgeTags)
	}
	if m.clearedfeature {
		edges = append(edges, banner.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeTags:
		return m.clearedtags
	case banner.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeTags:
		m.ResetTags()
		return nil
	case banner.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op             Op
	typ            string
	id             *int
	feature_name   *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	banners        map[int]struct{}
	removedbanners map[int]struct{}
	clearedbanners bool
	done           bool
	oldValue       func(context.Context) (*Feature, error)
	predicates     []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id int) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatureName sets the "feature_name" field.
func (m *FeatureMutation) SetFeatureName(s string) {
	m.feature_name = &s
}

// FeatureName returns the value of the "feature_name" field in the mutation.
func (m *FeatureMutation) FeatureName() (r string, exists bool) {
	v := m.feature_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureName returns the old "feature_name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldFeatureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureName: %w", err)
	}
	return oldValue.FeatureName, nil
}

// ResetFeatureName resets all changes to the "feature_name" field.
func (m *FeatureMutation) ResetFeatureName() {
	m.feature_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBannerIDs adds the "banners" edge to the Banner entity by ids.
func (m *FeatureMutation) AddBannerIDs(ids ...int) {
	if m.banners == nil {
		m.banners = make(map[int]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banner entity.
func (m *FeatureMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banner entity was cleared.
func (m *FeatureMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banner entity by IDs.
func (m *FeatureMutation) RemoveBannerIDs(ids ...int) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banner entity.
func (m *FeatureMutation) RemovedBannersIDs() (ids []int) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *FeatureMutation) BannersIDs() (ids []int) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *FeatureMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.feature_name != nil {
		fields = append(fields, feature.FieldFeatureName)
	}
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldFeatureName:
		return m.FeatureName()
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldFeatureName:
		return m.OldFeatureName(ctx)
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldFeatureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureName(v)
		return nil
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldFeatureName:
		m.ResetFeatureName()
		return nil
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banners != nil {
		edges = append(edges, feature.EdgeBanners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbanners != nil {
		edges = append(edges, feature.EdgeBanners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanners {
		edges = append(edges, feature.EdgeBanners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeBanners:
		return m.clearedbanners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeBanners:
		m.ResetBanners()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tag_name       *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	banners        map[int]struct{}
	removedbanners map[int]struct{}
	clearedbanners bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagName sets the "tag_name" field.
func (m *TagMutation) SetTagName(s string) {
	m.tag_name = &s
}

// TagName returns the value of the "tag_name" field in the mutation.
func (m *TagMutation) TagName() (r string, exists bool) {
	v := m.tag_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTagName returns the old "tag_name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagName: %w", err)
	}
	return oldValue.TagName, nil
}

// ResetTagName resets all changes to the "tag_name" field.
func (m *TagMutation) ResetTagName() {
	m.tag_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBannerIDs adds the "banners" edge to the Banner entity by ids.
func (m *TagMutation) AddBannerIDs(ids ...int) {
	if m.banners == nil {
		m.banners = make(map[int]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banner entity.
func (m *TagMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banner entity was cleared.
func (m *TagMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banner entity by IDs.
func (m *TagMutation) RemoveBannerIDs(ids ...int) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banner entity.
func (m *TagMutation) RemovedBannersIDs() (ids []int) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *TagMutation) BannersIDs() (ids []int) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *TagMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tag_name != nil {
		fields = append(fields, tag.FieldTagName)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTagName:
		return m.TagName()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldTagName:
		return m.OldTagName(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagName(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldTagName:
		m.ResetTagName()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banners != nil {
		edges = append(edges, tag.EdgeBanners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbanners != nil {
		edges = append(edges, tag.EdgeBanners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanners {
		edges = append(edges, tag.EdgeBanners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBanners:
		return m.clearedbanners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBanners:
		m.ResetBanners()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
